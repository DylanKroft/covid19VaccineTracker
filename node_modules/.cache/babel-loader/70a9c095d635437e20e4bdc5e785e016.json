{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = getDirection;\n\nvar _functions = require(\"./functions\");\n/**\n * Checks the intended tip direction and falls back if not enough space\n */\n\n\nfunction checkLeftRightWidthSufficient(tip, target, distance, bodyPadding) {\n  var targetRect = target.getBoundingClientRect();\n  var deadSpace = Math.min(targetRect.left, document.documentElement.clientWidth - targetRect.right);\n  return tip.offsetWidth + target.offsetWidth + distance + bodyPadding + deadSpace < document.documentElement.clientWidth;\n}\n\nfunction checkTargetSufficientlyVisible(target, tip, props) {\n  var targetRect = target.getBoundingClientRect();\n  var bottomOverhang = targetRect.bottom > window.innerHeight;\n  var topOverhang = targetRect.top < 0; // if the target is taller than the viewport (and we know there's sufficient left/right width before this is called),\n  // then go with the left/right direction as top/bottom will both be off screen\n\n  if (topOverhang && bottomOverhang) {\n    return true;\n  } // if the target is bigger than the tip, we need to check if enough of the target is visible\n\n\n  if (target.offsetHeight > tip.offsetHeight) {\n    var halfTargetHeight = target.offsetHeight / 2;\n    var arrowClearance = props.arrowSize + _functions.minArrowPadding;\n    var bottomOverhangAmount = targetRect.bottom - window.innerHeight;\n    var topOverhangAmount = -targetRect.top;\n    var targetCenterToBottomOfWindow = halfTargetHeight - bottomOverhangAmount;\n    var targetCenterToTopOfWindow = halfTargetHeight - topOverhangAmount;\n    return targetCenterToBottomOfWindow >= arrowClearance && targetCenterToTopOfWindow >= arrowClearance;\n  } // otherwise just check that the whole target is visible\n\n\n  return !bottomOverhang && !topOverhang;\n}\n\nfunction checkForArrowOverhang(props, arrowStyles, bodyPadding) {\n  var scrollLeft = (0, _functions.getScrollLeft)();\n  var hasLeftClearance = arrowStyles.positionStyles.left - scrollLeft > bodyPadding;\n  var hasRightClearance = arrowStyles.positionStyles.left + props.arrowSize * 2 < scrollLeft + document.documentElement.clientWidth - bodyPadding;\n  return !hasLeftClearance || !hasRightClearance;\n}\n\nfunction getDirection(currentDirection, tip, target, props, bodyPadding, arrowStyles, recursive) {\n  // can't switch until target is rendered\n  if (!target) {\n    return currentDirection;\n  }\n\n  var targetRect = target.getBoundingClientRect();\n  var arrowSpacing = (0, _functions.getArrowSpacing)(props); // this is how much space is needed to display the tip above or below the target\n\n  var heightOfTipWithArrow = tip.offsetHeight + arrowSpacing + bodyPadding;\n  var spaceBelowTarget = window.innerHeight - targetRect.bottom;\n  var spaceAboveTarget = targetRect.top;\n  var hasSpaceBelow = spaceBelowTarget >= heightOfTipWithArrow;\n  var hasSpaceAbove = spaceAboveTarget >= heightOfTipWithArrow;\n\n  switch (currentDirection) {\n    case 'right':\n      // if the window is not wide enough try top (which falls back to down)\n      if (!checkLeftRightWidthSufficient(tip, target, arrowSpacing, bodyPadding) || !checkTargetSufficientlyVisible(target, tip, props)) {\n        return getDirection('up', tip, target, arrowSpacing, bodyPadding, arrowStyles, true);\n      }\n\n      if (document.documentElement.clientWidth - targetRect.right < tip.offsetWidth + arrowSpacing + bodyPadding) {\n        return 'left';\n      }\n\n      return 'right';\n\n    case 'left':\n      // if the window is not wide enough try top (which falls back to down)\n      if (!checkLeftRightWidthSufficient(tip, target, arrowSpacing, bodyPadding) || !checkTargetSufficientlyVisible(target, tip, props)) {\n        return getDirection('up', tip, target, arrowSpacing, bodyPadding, arrowStyles, true);\n      }\n\n      if (targetRect.left < tip.offsetWidth + arrowSpacing + bodyPadding) {\n        return 'right';\n      }\n\n      return 'left';\n\n    case 'up':\n      if (!recursive && arrowStyles && checkForArrowOverhang(props, arrowStyles, bodyPadding)) {\n        return getDirection('left', tip, target, arrowSpacing, bodyPadding, arrowStyles, true);\n      }\n\n      if (!hasSpaceAbove) {\n        if (hasSpaceBelow) {\n          return 'down';\n        }\n\n        if (!recursive && checkLeftRightWidthSufficient(tip, target, arrowSpacing, bodyPadding)) {\n          return getDirection('right', tip, target, arrowSpacing, bodyPadding, arrowStyles, true);\n        }\n      }\n\n      return 'up';\n\n    case 'down':\n    default:\n      if (!recursive && arrowStyles && checkForArrowOverhang(props, arrowStyles, bodyPadding)) {\n        return getDirection('right', tip, target, arrowSpacing, bodyPadding, arrowStyles, true);\n      }\n\n      if (!hasSpaceBelow) {\n        // if there's no space below, but space above, switch to that direction\n        if (hasSpaceAbove) {\n          return 'up'; // if there's not space above or below, check if there would be space left or right\n        }\n\n        if (!recursive && checkLeftRightWidthSufficient(tip, target, arrowSpacing, bodyPadding)) {\n          return getDirection('right', tip, target, arrowSpacing, bodyPadding, arrowStyles, true);\n        } // if there's no space in any direction, default to the original direction\n\n      }\n\n      return 'down';\n  }\n}","map":{"version":3,"sources":["/Users/dylankroft/Documents/GitHub/Projects/vaxtrax/node_modules/react-tooltip-lite/dist/getDirection.js"],"names":["Object","defineProperty","exports","value","getDirection","_functions","require","checkLeftRightWidthSufficient","tip","target","distance","bodyPadding","targetRect","getBoundingClientRect","deadSpace","Math","min","left","document","documentElement","clientWidth","right","offsetWidth","checkTargetSufficientlyVisible","props","bottomOverhang","bottom","window","innerHeight","topOverhang","top","offsetHeight","halfTargetHeight","arrowClearance","arrowSize","minArrowPadding","bottomOverhangAmount","topOverhangAmount","targetCenterToBottomOfWindow","targetCenterToTopOfWindow","checkForArrowOverhang","arrowStyles","scrollLeft","getScrollLeft","hasLeftClearance","positionStyles","hasRightClearance","currentDirection","recursive","arrowSpacing","getArrowSpacing","heightOfTipWithArrow","spaceBelowTarget","spaceAboveTarget","hasSpaceBelow","hasSpaceAbove"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = getDirection;\n\nvar _functions = require(\"./functions\");\n\n/**\n * Checks the intended tip direction and falls back if not enough space\n */\nfunction checkLeftRightWidthSufficient(tip, target, distance, bodyPadding) {\n  var targetRect = target.getBoundingClientRect();\n  var deadSpace = Math.min(targetRect.left, document.documentElement.clientWidth - targetRect.right);\n  return tip.offsetWidth + target.offsetWidth + distance + bodyPadding + deadSpace < document.documentElement.clientWidth;\n}\n\nfunction checkTargetSufficientlyVisible(target, tip, props) {\n  var targetRect = target.getBoundingClientRect();\n  var bottomOverhang = targetRect.bottom > window.innerHeight;\n  var topOverhang = targetRect.top < 0; // if the target is taller than the viewport (and we know there's sufficient left/right width before this is called),\n  // then go with the left/right direction as top/bottom will both be off screen\n\n  if (topOverhang && bottomOverhang) {\n    return true;\n  } // if the target is bigger than the tip, we need to check if enough of the target is visible\n\n\n  if (target.offsetHeight > tip.offsetHeight) {\n    var halfTargetHeight = target.offsetHeight / 2;\n    var arrowClearance = props.arrowSize + _functions.minArrowPadding;\n    var bottomOverhangAmount = targetRect.bottom - window.innerHeight;\n    var topOverhangAmount = -targetRect.top;\n    var targetCenterToBottomOfWindow = halfTargetHeight - bottomOverhangAmount;\n    var targetCenterToTopOfWindow = halfTargetHeight - topOverhangAmount;\n    return targetCenterToBottomOfWindow >= arrowClearance && targetCenterToTopOfWindow >= arrowClearance;\n  } // otherwise just check that the whole target is visible\n\n\n  return !bottomOverhang && !topOverhang;\n}\n\nfunction checkForArrowOverhang(props, arrowStyles, bodyPadding) {\n  var scrollLeft = (0, _functions.getScrollLeft)();\n  var hasLeftClearance = arrowStyles.positionStyles.left - scrollLeft > bodyPadding;\n  var hasRightClearance = arrowStyles.positionStyles.left + props.arrowSize * 2 < scrollLeft + document.documentElement.clientWidth - bodyPadding;\n  return !hasLeftClearance || !hasRightClearance;\n}\n\nfunction getDirection(currentDirection, tip, target, props, bodyPadding, arrowStyles, recursive) {\n  // can't switch until target is rendered\n  if (!target) {\n    return currentDirection;\n  }\n\n  var targetRect = target.getBoundingClientRect();\n  var arrowSpacing = (0, _functions.getArrowSpacing)(props); // this is how much space is needed to display the tip above or below the target\n\n  var heightOfTipWithArrow = tip.offsetHeight + arrowSpacing + bodyPadding;\n  var spaceBelowTarget = window.innerHeight - targetRect.bottom;\n  var spaceAboveTarget = targetRect.top;\n  var hasSpaceBelow = spaceBelowTarget >= heightOfTipWithArrow;\n  var hasSpaceAbove = spaceAboveTarget >= heightOfTipWithArrow;\n\n  switch (currentDirection) {\n    case 'right':\n      // if the window is not wide enough try top (which falls back to down)\n      if (!checkLeftRightWidthSufficient(tip, target, arrowSpacing, bodyPadding) || !checkTargetSufficientlyVisible(target, tip, props)) {\n        return getDirection('up', tip, target, arrowSpacing, bodyPadding, arrowStyles, true);\n      }\n\n      if (document.documentElement.clientWidth - targetRect.right < tip.offsetWidth + arrowSpacing + bodyPadding) {\n        return 'left';\n      }\n\n      return 'right';\n\n    case 'left':\n      // if the window is not wide enough try top (which falls back to down)\n      if (!checkLeftRightWidthSufficient(tip, target, arrowSpacing, bodyPadding) || !checkTargetSufficientlyVisible(target, tip, props)) {\n        return getDirection('up', tip, target, arrowSpacing, bodyPadding, arrowStyles, true);\n      }\n\n      if (targetRect.left < tip.offsetWidth + arrowSpacing + bodyPadding) {\n        return 'right';\n      }\n\n      return 'left';\n\n    case 'up':\n      if (!recursive && arrowStyles && checkForArrowOverhang(props, arrowStyles, bodyPadding)) {\n        return getDirection('left', tip, target, arrowSpacing, bodyPadding, arrowStyles, true);\n      }\n\n      if (!hasSpaceAbove) {\n        if (hasSpaceBelow) {\n          return 'down';\n        }\n\n        if (!recursive && checkLeftRightWidthSufficient(tip, target, arrowSpacing, bodyPadding)) {\n          return getDirection('right', tip, target, arrowSpacing, bodyPadding, arrowStyles, true);\n        }\n      }\n\n      return 'up';\n\n    case 'down':\n    default:\n      if (!recursive && arrowStyles && checkForArrowOverhang(props, arrowStyles, bodyPadding)) {\n        return getDirection('right', tip, target, arrowSpacing, bodyPadding, arrowStyles, true);\n      }\n\n      if (!hasSpaceBelow) {\n        // if there's no space below, but space above, switch to that direction\n        if (hasSpaceAbove) {\n          return 'up'; // if there's not space above or below, check if there would be space left or right\n        }\n\n        if (!recursive && checkLeftRightWidthSufficient(tip, target, arrowSpacing, bodyPadding)) {\n          return getDirection('right', tip, target, arrowSpacing, bodyPadding, arrowStyles, true);\n        } // if there's no space in any direction, default to the original direction\n\n      }\n\n      return 'down';\n  }\n}"]},"metadata":{},"sourceType":"script"}